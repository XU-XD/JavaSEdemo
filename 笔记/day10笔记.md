# Day10

## 今日内容

1.  多态

2.  抽象类

3.  接口

4.  匿名内部类

## 多态

1.  概述：用来描述事物的多种状态

2.  对象的多态性：一个对象可以有不同的类型来表示；一个对象可以通过不同的类型引用
    来接收。

类型的多态性：一个类型可以有不同的子类；一个类型引用可以接收不同的子类对象

1.  多态实现的前提：

2.  两个类之间要有子父类的继承关系 或者 接口和实现类的实现关系

3.  使用父类的类型接收子类的对象 或者 接口引用变量接收实现类对象

### 多态访问属性的特点

1.  特点：

编译看左边，运行看左边

1.  解释：

编译看左边：要访问某一个属性，编译时期：先看=左边的类型中有没有该变量的定义，
如果左边的类型中有定义该变量，就能编译成功，否则编译失败。

运行看左边：再运行时期，看=左边的类型如何如何给该属性赋值，左边的类型中如何
个属性赋值，访问结果就是哪一个值。

代码

![](media/212224a233330708d2a402d27a54ca8d.png)

### 多态访问方法的特点

1.  特点：

编译看左边，运行看右边

1.  解释：

访问某个方法，编译时期看=左边的类型中有没有定义该方法，如果定义了就能使用，
如果没有定义，就不能使用，编译失败；

再运行时期，看=右边的类型中对该方法是如何实现，右边的类型如何实现该方法，就
如何执行。

代码

![](media/5fc90f4d74161f0985281a41cb0152ec.png)

### 多态访问静态方法的特点

1.  特点：

编译看左边，运行看左边。

1.  说明：

静态方法被哪一个类型的引用变量调用，就执行哪一个类中的实现内容

不会随着子类的不同而不同

### 超人案例

### 向上向下转型

1.  向上转型：

使用父类的引用变量，接收子类的对象

转型之后，访问权限：

一旦向上转型之后，该变量访问的权限变小，只能先看父类中有没有定义过，父类
中定义过才能使用，父类中没有定义过，就不能使用。

1.  向下转型：

将指向子类对象的父类引用，恢复为子类的引用

SuperMan sum = (SuperMan)man;

向下转型之后，转型后的变量访问权限：

就恢复为和子类对象一样的访问访问：既可以访问父类的也可以访问本类的

1.  图示理解：

![](media/44d632724f9c3f78960c10402d252f9c.png)

总结：

（1）如果使用父类的引用变量接收子类对象，那么该变量的访问权限和super关键
字相同，直接指向父类的对象。

（2）如果使用本类的引用变量接收本类的对象，那么该变量访问权限和this一样

（3）多态访问方法，根据动态绑定机制访问

### instanceof关键字

1.  使用格式：

引用变量 instanceof 类型

1.  特点：

判断左边变量接收的对象是否属于右边的类型，如果属于右边的类型，返回值就为true

如果左边的变量接收的对象不属于右边的类型，返回值就为false

1.  作用：

当需要向下转型时，不确定该变量接收的对象属于哪一个类型，可以使用该关键字先判
断，避免出现类型转换异常。

代码

![](media/49d91c456f72cc7119d5be5cf22a5bb1.png)

### 多态的好处

1.  好处：

将来定义某个方法的参数时，可以将高参数类型定义为父类的类型，定义之后，可以传
递任何子类的对象，传递的是哪一个子类，执行的内容会执行该子类的实现方式。

代码

![](media/6df18560f7e802652928f8ea0b29d10e.png)

## 抽象类

### 抽象方法

1.  概述：只有方法的声明，没有方法的实现

2.  特点：

3.  抽象方法不需要定义实现内容，大括号都不需要

4.  抽象方法一般使用关键字来修饰：abstract

### 抽象类的特点

1.  抽象类：使用abstract关键字修饰的类型

2.  抽象类和抽象方法的关系：

抽象方法需要在抽象类中定义

抽象类中不一定要定义抽象方法

抽象类中也可以定义非抽象方法

1.  抽象类不能实例化

不能创建对象

1.  抽象类和普通类之间也可以是继承关系

如果子类继承抽象父类之后，重写了父类中所有的抽象方法，那么该子类可以正常创建
对象是一个普通类型

如果子类继承抽象父类之后，没有选择重写完父类中的所有抽象方法，那么该子类只能
定义为一个抽象类，不能继续创建对象。

代码

![](media/4f14f8018e7694d5601df3e9f9aecd66.png)

### 抽象类成员特点

1.  抽象类中成员属性的特点：

抽象类中可以正常给该类型定义属性（目的：用于让子类继承）

属性名本身有一层抽象化的含义，不能再次抽象

1.  抽象类中成员方法的特点：

抽象类中可以定义抽象方法，也可以定义非抽象方法

1.  抽象类中一样可以定义静态方法，也可以被子类继承

2.  抽象类中可以不可以定义（需不需要定义）构造方法？

抽象类虽然不能创建对象，但是也需要定义构造方法

原因：因为在初始化子类对象数据之前，需要先初始化父类中的数据，那么就需要使用
父类中的构造方法。

### 抽象类的应用：模板设计模式

1.  概述：

每一个子类中的共有内容可以定义在父类中，当每一个子类需要该功能，但是有不同的
实现内容时，可以将该功能定义为抽象的，也可以将该类型定义为抽象类。

模板类代码

![](media/8f4fac6e46c214a324781530326873e6.png)

子类代码

![](media/a3cb8b3a2b2d5e0bd4b5ee8105843f1d.png)

## 接口【jdk1.8之前】

1.  概述：

生活中的角度：接口用来表示一些指定的规则，想要使用接口就要满足接口定义的要求

Java语言的角度：规则可以通过抽象方法来表示；接口就是专门来定义抽象方法的一个
特殊类型。

1.  接口的特点：

2.  定义接口的关键字：interface

3.  接口中只可以定义抽象方法，不可以定义非抽象方法

4.  类和接口之间的关系：

不是继承关系，而是实现关系

实现接口的关键字：implements

类型实现一个接口之后，接口中的抽象方法，也能被该类所继承

1.  接口不能实例化（不能创建对象）

2.  接口和普通类以及抽象类一样，使用之前先编译

### 接口的成员特点

1.  接口中变量的特点：

接口中不能存在变量，只能存在常量

如果在接口中定义了一个变量，那么该变量会默认通过：static final来进行修饰

1.  接口中方法的特点：

接口中只可以定义抽象方法，不能定义非抽象方法

如果定义一个抽象方法，可以省略关键字：abstract

1.  接口中静态方法特点：

接口中可以定义静态方法

1.  接口中可以不可以（需不需要）定义构造方法？

接口中不需要定义构造方法

1.  问题：一个类型是否需要定义构造方法跟当前类可以不可以创建对象有关？

没有关系；

一个类型是否需要定义构造方法跟谁有关？

跟当前类中是否可以定义属性有关，当前类中可以定义属性，就需要定义构造
方法给给它初始化，如果不能定义属性，就不需要定义构造来初始化

### 类与类、类与接口、接口与接口的关系

1.  类与类：继承关系 extends

可以单继承、可以多层继承、不可以多继承

1.  类与接口(interface)：实现关系 implements

可以单实现、可以多实现、不可以多层实现

单实现：实现之后，该类型可以继承接口的每一个抽象方法

多实现：实现多个接口之后，可以继承每一个接口的方法

不能多层实现：因为一个类型实现一个接口之后，那么该类和其他类之间不能
是实现关系，只能是继承关系。

1.  接口与接口之间： 继承关系 extends

可以单继承、可以多继承、可以多层继承

### 抽象类和接口的区别

1.  相同点：

接口和抽象类都可以定义抽象方法

1.  不同点：

2.  抽象类可以定义非抽象方法；接口不能定义非抽象方法

3.  抽象类中可以定义属性；接口中不可以定义属性

4.  抽象类需要定义构造方法；接口不需要定义构造方法

5.  抽象类和接口的使用：

类中一般定义物体固有的属性和行为

接口中一般定义通过拓展学习的来的行为

猫：姓名、年龄、捉老鼠、吃饭（吃鱼）、爬树

狗：姓名、年龄、看家、吃饭（吃肉）

猴子：姓名、年龄、吃饭（吃香蕉）、爬树

## 匿名内部类

1.  概述：匿名内部类属于局部内部类，但是该类型没有重新起名

2.  格式：

接口引用变量 变量名 = new 接口名(){

接口方法的重写;

};

new 接口名(){

接口方法的重写;

}.方法名();

1.  匿名内部类不仅适用于接口的实现，也适用于抽象类的使用

代码

![](media/07ee1c03b79f543709dfdaa8f4ddba34.png)
